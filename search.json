[{"title":"Code Conventions in openVFIFE","url":"/2021/06/13/openVFIFE_code_conventions/","content":"Code Conventions 编码规范\r\n参考Google C++ Style Guide\r\n1. Naming Conventions 命名规范\r\n1.1 通用命名规则\r\n尽可能给有描述性的命名，别心疼空间，毕竟让代码易于新读者理解很重要。不要用只有项目开发者能理解的缩 写，也不要通过砍掉几个字母来缩写单词。\r\n// goodint price_count_reader;int num_errors;int num_dns_connections;// terribleint n;int nerr;int n_comp_conns;int wgc_connections;int pc_readers;int cstmr_id;\r\n1.2 文件命名\r\n文件名要全部小写, 可以包含下划线 () 或连字符 (-). 按项目约定来. 如果并没有项目约定， ”” 更好。 可接受的文件命名:\r\nmy_useful_class.cpp\r\n1.3 类型命名\r\nTip: 类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum.\r\n所有类型命名——类, 结构体, 类型定义 (typedef), 枚举——均使用相同约定. 例如:\r\n// classes and structsclass UrlTable &#123; ... &#125;;class UrlTableTester &#123; ... &#125;;struct UrlTableProperties &#123; ... &#125;;// typedefstypedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;// enumsenum UrlTableErrors &#123; ... &#125;;\r\n1.4 变量命名\r\nTip: 变量名一律小写，单词之间用下划线连接。类的成员变量以下划线结尾，但结构体的就不用，如：a_local_variable, a_struct_data_member, a_class_data_member_。\r\n\r\n普通变量命名：\r\n\r\n// goodstring table_name;string tablename;// terriblestring tableName;\r\n\r\n类数据成员\r\n不管是静态的还是非静态的，类数据成员都可以和普通变量一样，但是要接下划线\r\nclass TableInfo&#123;\tprivate:    \tstring table_name_;    \tstring tablename_;    \tstatic Pool&lt;TableInfo&gt;* pool_;&#125;\r\n结构体变量\r\n不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样，不用像类那样接下划线\r\nStruct UrlTableProperties&#123;\tstring name;\tint num_entries;&#125;\r\n全局变量\r\n对全局变量没有特别要求，少用就好，但如果要用，可以用g_标志作为前缀，一遍更好地区分局部变量\r\n\r\n1.5 常量命名\r\nTip: 在全局或类里的常量名称前加k，如kDaysInAWeek，且除去开头的k之外每个单词开头字母均大写。所有编译时常量，无论是局部的，全局的还是类中的，和其他变量稍微区别一下。k后接大写字母开头的单词 const int kDaysInAWeek = 7; 这规则适用于编译时的局部作用域常量，不过要按变量规则来命名也可以。\r\n1.6 函数命名\r\nTip: 常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配:MyExcitingFunciton(),MyExcitingMethod(), my_exciting_memeber_variable(),set_my_exciting_member_variable()\r\n\r\n常规函数\r\n函数名的每个首字母大写，没有下划线\r\n如果您的某函数出错时就要直接 crash, 那么就在函数名加上 OrDie. 但这函数本身必须集成在产品代码 里，且平时也可能会出错。\r\nAddTableEntry();DeleteUrl();OpenFileOrDie();\r\n取值和设值函数\r\n取值（ Accessors）和设值（ Mutators）函数要与存取的变量名匹配. 这儿摘录一个类, num_entries_是该 类的实例变量:\r\nclass MyClass&#123;    public:    \t...        int num_entries() const &#123;return num_entries_;&#125;;    \tvoid set_num_entries(int num_entries) &#123;num_entries_ = num_entries;&#125;;        private:    \tint num_entries_;&#125;\r\n其它非常短小的内联函数名也可以用小写字母, 例如. 如果你在循环中调用这样的函数甚至都不用缓存其 返回值, 小写命名就可以接受\r\n\r\n1.7 名字空间命名\r\nTip: 名字空间用小写字母命名, 并基于项目名称和目录结构: google_awesome_project\r\n1.8 枚举命名\r\nTip: 枚举的命名应当和常量或者宏一致：kEnumName或是ENUM_NAME\r\nenum UrlTableErros&#123;    kOK = 0,    kErrorOutOfMemory,    kErrorMalformedInput,&#125;\r\n","categories":["openVFIFE"]},{"title":"User Guide of openVFIFE","url":"/2021/06/13/openVFIFE_quick_strart/","content":"User Guide\r\nWelcome to openVFIFE.\r\nThis is a very short guide on how to get started with openVFIFE. It has a dual purpose. It serves as a minimal introduction to the openVFIFE library for people who want to start coding as soon as possible. You can also read this page as the first part of the Tutorial, which explains the library in more detail.\r\nWhat is openVFIFE?\r\nThe openVFIFE is a C++ library for structural nonliear dynamic analysis and discontinuous behaviour analysis based on vector form intrinsic finite element method (referred to as VFIFE).\r\nMotivation:  The VFIFE has already been applied in many research fields, and has made great achievements. However, there is no available software/platform for it, which is an main obstcale of the development and popularization of VFIFE. On the other hand, the author (Tan Biao or GinkGo) tries to introduce VFIFE into the collapse analysis of transmission tower. For this reason, the openVFIFE has been implemented to provide a general VFIFE analysis software/platform for researchers or engineers who interested in VFIFE.\r\nFinal goal:  The openVFIFE is currently released in the form of C++ library. But it will never stop here. A completely independent cross-platform software package is my ultimate goal. The author will continue to work hard for this. And the contributions from all of you are quite important. If you have any suggestions or advices, or want to contribute new codes , please contact me (ginkgoltd@outlook.com).\r\nMain Characters: \r\n\r\nopenVFIFE is a completely open source library, which strictly abides by GNU/GPL v3.0 License (see LICENSE file).\r\nopenVFIFE is fast.\r\nopenVFIFE is reliable.\r\nopenVFIFE is user- and developer-friendly.\r\nopenVFIFE is scalable.\r\n\r\nQuick Start\r\nHow to install openVFIFE?\r\nIn order to use  openVFIFE, you just need to download and extract openVFIFE's source code. The header files in the headers subdirectory and the static library file in the './library' are the only files required to compile programs using  openVFIFE. The header files are the same for all platforms. It is not necessary to use CMake or install anything.\r\nA simple first program\r\nHere is a rather simple program to get you started.\r\nConsider a single bar structure(as shown in the following figure) , the length \\(l = 10m\\), the section area is \\(1m^2\\), Young's modulus \\(E=10^6Pa\\) , mass density \\(\\rho = 10 kg/m^3\\). In this case, I want to show you how to use openVFIFE to solve static problems, and explain the influence of damping coefficient and time step.\r\n\r\n#include &quot;../../headers/structsystem.h&quot; // see ./examples/example2/example2.cppusing namespace std;int main()&#123;    // create system    StructSystem system = StructSystem(1);    system.setJobname(&quot;example2&quot;);    // solve parameters    double endTime = 50.0;\t\t// total time, s    double h = 1.0e-3;\t\t    // time step, s     double p = 100;\t\t\t    // load, N    double zeta = 0.5;\t\t\t// damping coefficient    // create particles    Particle * p1 = new Particle(1, 0, 0);    Particle * p2 = new Particle(2, 10, 0);    system.addParticle(p1);    system.addParticle(p2);    // create material    LinearElastic mat = LinearElastic(1);    mat.setE(1.0E6);    mat.setDensity(10);    // create section    CustomSectionParas paras = &#123;.A=1, .Sy=0, .Sz=0, .SHy=0, .SHz=0,                                .CGy=0, .CGz=0.0, .Iyy=10, .Izz=10, .Iyz=10&#125;;    CustomSection sect = CustomSection(1, paras);    // create elements    Link2D* e = new Link2D(1, p1, p2, &amp;mat, &amp;sect);    system.addElement(e);    // constraints    DOF c1 = &#123;.key = &#123;true, true, true, true, true, true&#125;,              .val = &#123;0, 0, 0, 0, 0, 0&#125;&#125;;    DOF c2 = &#123;.key = &#123;false, true, true, true, true, true&#125;,              .val = &#123;0, 0, 0, 0, 0, 0&#125;&#125;;    system.addConstraint(1, c1);    system.addConstraint(2, c2);    // save model    string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/model&quot;;    system.saveModel(path);    system.info();      // print structsystem information    StdArray6d f1 = &#123;100, 0, 0, 0, 0, 0&#125;;    int nStep = ceil(endTime/h);    cout &lt;&lt; nStep &lt;&lt; endl;    int interval = ceil(0.1/h);    for (int i = 0; i &lt;= nStep; i++)    &#123;        if (i == 0)        &#123;            system.addExternalForce(2, f1);            // add external force            system.solve(h, zeta, true);            system.setInternalForce();        &#125;        else        &#123;            system.solve(h, zeta);            system.clearParticleForce();            system.setExternalForce(2, f1);            system.setInternalForce();        &#125;        // save results        if (i % interval == 0)        &#123;            string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/&quot; +                          to_string(i*h);            system.saveParticleResult(path);            system.saveElementResult(path);            system.saveSupportReact(path);        &#125;    &#125;    system.releaseContainers(); // release the projects, it&#x27;s important for avoiding memory leakage    return 0;&#125;\r\nWe will explain the program after telling you how to complie it.\r\nCompiling and running your first program\r\nThe only thing that you need to keep in mind when compiling the above program is that the compiler must be able to find the openVFIFE header files. The directory in which you placed openVFIFEs source code must be in the include path. With GCC you use the -L option to achieve this, so you can compile the program with a command like this:\r\ng++ -statick -O3 xxx.cpp -L /path/to/static/library -lvfife -o xxx.out\r\nOn Windows or Mac OS, you need to comiple all the files by yourself. In future, I will provide a makefile for cmake, but now you should compile openVFIFE by yourself. Here are the commands for compile a static library in Linux.\r\n# change to the src directory$ g++ -c -O3 element.cpp gridsection.cpp integrator.cpp material.cpp particle.cpp section.cpp structsystem.cpp $ ar rcs libvfife.a element.o gridsection.o integrator.o material.o particle.o section.o structsystem.o\r\nExplanation of the first program\r\nBasic procedures of openVFIFE\r\nopenVFIFE is quite simple and intuitive. The basic procedures of a calculation is as follows:\r\n\r\ncreate a StructSystem to manage all struct objects\r\ncreate Particles\r\ncreate Materials and Sections (necessary in bar structures)\r\ncreate Elements\r\nadd constraints\r\nadd external force and solve\r\n\r\nstep 1: create a StructSystem object\r\n// create systemStructSystem system = StructSystem(1);system.setJobname(&quot;example2&quot;);\r\nStructSystem::StructSystem(int id) is the constructor of the StructSystem class, you need to give a int number for represent the id of the structrure. And StructSystem::setjobname(const std::string &amp;jobname) give a method to assign the name of the project, which will help create a ./jobname directory in the current working directory to restore the computing results.\r\nstep 2: create Particles\r\n// create particlesParticle* p1 = new Particle(1, 0, 0);Particle* p2 = new Particle(2, 10, 0);system.addParticle(p1);system.addParticle(p2);\r\nParticle::Particle(int id, double x, double y, double z=0) create a Particle object, which has a unique id and located at \\((x, y, z)\\) in global coordinate system. Then using StructSystem::addParticle(Particle* p) to put the Particle object into system object in order to manage the Particle objects.\r\nstep 3: create Materials and Sections (necessary in bar structures)\r\n// create materialLinearElastic mat = LinearElastic(1);mat.setE(1.0E6);mat.setDensity(10);// create sectionCustomSectionParas paras = &#123;.A=1, .Sy=0, .Sz=0, .SHy=0, .SHz=0,                            .CGy=0, .CGz=0.0, .Iyy=10, .Izz=10, .Iyz=10&#125;;CustomSection sect = CustomSection(1, paras);\r\nLinearElastic::LinearElastic(int id) create a LinearElastic material object; LinearElastic::setE(double val) and LinearElastic::setDensity(double val) set the Young's modulus and density of the material respectively. openVFIFE also provide UniIdeal and UniBilinear for uniaxial rate-independent plastic material, you can read the headers in ./headers/material directory.\r\nCustomSetcion::CustomSection(int id, const CustomSectionParas &amp;para) create a CustomSection object, which means you can assign the section characteristics. openVFIFE also provide Rectangle, AngleSteel and Ctube sections, you can read the headers in ./headers/section directory.\r\nstep 4: create Elements\r\n// create elementsLink2D* e = new Link2D(1, p1, p2, &amp;mat, &amp;sect);system.addElement(e);\r\nLink2D::Link2D(int id, Particle* pi, Particle* pj, const BaseMaterial* mat, const BaseSection* sect) create a planar link element. StructSystem::addElement(BaseElement* e) put the element into system.\r\nstep 5: add constraints\r\n// constraints, Ux, Uy, Uz, Rotx, Roty, RotzDOF c1 = &#123;.key = &#123;true, true, true, true, true, true&#125;,          .val = &#123;0, 0, 0, 0, 0, 0&#125;&#125;;DOF c2 = &#123;.key = &#123;false, true, true, true, true, true&#125;,          .val = &#123;0, 0, 0, 0, 0, 0&#125;&#125;;system.addConstraint(1, c1);system.addConstraint(2, c2);\r\nStructSystem::addConstraint(int pid, const DOF &amp;d) constraint Paricle pid.\r\nstep 6: add external force and solve\r\n// external force, typedef array&lt;double, 6&gt; StdArray6d;StdArray6d f1 = &#123;100, 0, 0, 0, 0, 0&#125;;int nStep = ceil(endTime/h);int interval = ceil(0.1/h);for (int i = 0; i &lt;= nStep; i++)&#123;    if (i == 0)\t// first step    &#123;\t\tsystem.addExternalForce(2, f1);            // add external force\t\tsystem.solve(h, zeta, true);\t\tsystem.setInternalForce();    &#125;    else\t   // n &gt; 1    &#123;\t\tsystem.solve(h, zeta);\t\tsystem.clearParticleForce();\t\tsystem.setExternalForce(2, f1);\t\tsystem.setInternalForce();    &#125;    // save results    if (i % interval == 0)    &#123;\t\tstring path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/&quot; + to_string(i*h);\t\tsystem.saveParticleResult(path);\t\tsystem.saveElementResult(path);\t\tsystem.saveSupportReact(path);\t&#125;&#125;\r\nint nStep = ceil(endTime/h); calculate the total time steps \\(n = \\frac{t}{\\Delta t}\\)\r\nIf you do not want save results of every step, you can set a int interval = ceil(0.1/h); for skip some steps.\r\nIn the first time step, we set external force by StructSystem::addExternalFroce(int pid, const StdArray6d &amp;force) of Particle (id). Then StructSystem::solve(double h, double zeta, const bool firststep) solve the gorverning equation at \\(t=0\\). Then StructSystem::setInternalForce() assign all element internal force to all Particles.\r\nIn the other step (\\(t&gt;0\\)), StructSystem::solve(double h, double zeta, const bool firststep=false) solve the governing equation (movement of all the particles). StructSystem::clearParticleForce() remove all the forces acted on the particles, and then StructSystem::setExternalForce(int pid, const StdArray6d &amp;force) add the external forces, StructSystem::setInternalForce() add the element internal force to all particles.\r\nstring path = system.workdir() + \"/\" + system.jobname() + \"/\" + to_string(i*h); set the directory for saving results. StructSystem::saveParticleResult(const string &amp;path), StructSystem::saveElementResult(const string &amp;path) and StructSystem::saveSupportReact(const string &amp;path) save the computing results of all particles, elements and support reactions.\r\nResults\r\nwhen \\(\\Delta t = 0.01\\), the axail force of the bar\r\n\r\n\r\n\r\n\\(\\zeta\\)\r\nTarget (N)\r\nopenVFIFE\r\n\r\n\r\n\r\n\r\n0.0\r\n100.0\r\n--\r\n\r\n\r\n0.5\r\n100.0\r\n100.0\r\n\r\n\r\n1.0\r\n100.0\r\n100.0\r\n\r\n\r\n\r\n\r\nif \\(\\zeta= 0.0\\), the axial force of the bar will not converge (umdamped free vibration); and when \\(\\zeta\\) increased, the answer will finally converge to the static solution, and the larger \\(\\zeta\\) is, the faster convergence is. Besides, \\(\\zeta\\) won't affect the static solution. Hence, for static problems, large \\(\\zeta\\) could be adopted to help converge.\r\nThe critical time step \\[\r\n\\Delta t_{critical} = \\frac{2l}{v_c} = \\frac{2l}{\\sqrt{E/\\rho}}=0.0316s\r\n\\] when \\(\\zeta= 0.5\\), the axail force of the bar\r\n\r\n\r\n\r\n\\(\\Delta t\\)\r\nTarget (N)\r\nopenVFIFE\r\n\r\n\r\n\r\n\r\n0.001\r\n100.0\r\n99.89860658682635\r\n\r\n\r\n0.01\r\n100.0\r\n99.89854111776447\r\n\r\n\r\n0.1\r\n100.0\r\nnan\r\n\r\n\r\n0.5\r\n100.0\r\nnan\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nFig. Axial Force of The Bar, (a) \\(\\Delta t = 0.001, 0.01\\), (b) \\(\\Delta t = 0.001, 0.01, 0.1, 0.5\\),\r\nIf \\(\\Delta t &gt; \\Delta t_{critical}\\), the solution will unconverge, hence it is important to assign time step. openVFIFE provides a autoTimeStep() function for setting proper time step automaticly.\r\nFor more examples, see ./examples.\r\nWhere to go from here?\r\nThe detailed and completed documentations for users and developers are still under construction. The author hope the researchers who are interested on vector form instrinsic finite element can contribute to this project for building a easy and robust general software.\r\nTODO LIST\r\n\r\n\r\nprovide a detailed and well organized documentation for users and developers\r\n\r\nwrite makefiles\r\n\r\nwrite a unittest for this library\r\n\r\nredesign and refactor the project to fit more incoming functions\r\n\r\nintroduce a script language (tcl/tk, lua or python3) to make the software easy to use\r\n\r\nUltimate Goal\r\n\r\nbuild a open source software like openSees and openFoam\r\n\r\n","categories":["openVFIFE"]},{"title":"谐波合成法的Python实现及其使用手册","url":"/2021/06/13/WAWS/","content":"程序地址：https://gitee.com/ginkgoltd/waws,\r\n编程语言：Python3\r\n作者：GinkGo\r\nEmail: ginkgoltd@outlook.com\r\n谐波合成法以功率谱作为权系数，与一系列带随机相位的三角级数的加权和来逐渐逼近随机过程，适用于指定谱特征的平稳高斯随机过程。该方法有恒幅谐波叠加法和加权振幅谐波叠加法(尚未阅读相关文献).\r\n谐波合成法基本步骤\r\nStep 1:  选取目标风速谱\\(S(w)\\)和相干函数\\(coh(x_i, x_j, y_i, y_j, z_i, z_j, f)\\),确定模拟点坐标\r\nStep 2: 生成互谱密度矩阵 \\[\r\nS(w) = \\begin{bmatrix} S_{11}(\\omega) &amp;  S_{12}(\\omega)  ...  &amp; S_{1n}(\\omega) \\\\\r\n                   S_{21}(\\omega) &amp;  S_{22}(\\omega)  ...  &amp; S_{2n}(\\omega) \\\\\r\n                   . &amp; ........ &amp; . \\\\\r\n                   . &amp; ........ &amp; . \\\\\r\n                   . &amp; ........ &amp; . \\\\\r\n                   S_{n1}(\\omega) &amp;  S_{n2}(\\omega)  ...  &amp; S_{nn}(\\omega) \\\\\\end{bmatrix}\\\\\r\nS_{ij}(\\omega)=\\sqrt{ S_{i}(\\omega) S_{j}(\\omega)}coh(x_i,x_j,y_i,y_j,z_i,z_j,\\omega)\r\n\\]\r\nStep 3: 对互谱密度矩阵进行cholesky分解 \\[\r\nS(w) =H(w) H^T(w)\\\\\\\\\r\nH(w) = \\begin{bmatrix} H_{11}(\\omega) &amp;  0 ...  &amp; 0 \\\\\r\n                   H_{21}(\\omega) &amp;  H_{22}(\\omega)  ...  &amp; 0 \\\\\r\n                   . &amp; ........ &amp; . \\\\\r\n                   . &amp; ........ &amp; . \\\\\r\n                   H_{n1}(\\omega) &amp; H_{n2}(\\omega)  ...  &amp; H_{nn}(\\omega) \\\\\\end{bmatrix}\r\n\\]\r\nStep 4: (option 1):  M. Shinuzuka提出的单索引频率法\r\n这种算法最简单, 只需互谱密度矩阵进行\\(N\\)次cholesky分解(\\(n \\times n\\)阶矩阵). 但是由于频率均匀分布可能导致模拟曲线出现周期性1. (具体情况尚未进行过详细地分析, 有机会在做吧, 暂且相信文献的结论) \\[\r\nV_j(t) = 2\\sqrt{\\Delta \\omega} \\sum_{m=1}^{j} \\sum_{l=1}^{N}|H_{jm}(\\omega_{l})cos(\\omega_l t + \\theta_{jm}(\\omega_l) + \\phi_{ml})\\\\\r\n\\omega_l = l\\Delta\\omega, l = 1,2,3,...,N\r\n\\]\r\nStep 4 (option 2):  Deodatis双索引频率法计算模拟点风速时程\r\n公式来源于(杨素珍)2 由于option 1可能存在模拟风速时程出现周期性的问题, 引入了双索引频率, 将频率微小扰量均匀分布在频率增量内, 这样既可以采用FFT算法, 又能保证模拟曲线的各态历经性. 但互谱密度矩阵的分解数量将明显提升, 达到\\(N \\times n\\)次(\\(N\\)为频率等分数, \\(n\\)为模拟点数), 这样运算量将会增加; (但似乎采用numpy.linalg.cholesky()函数计算效率并不低) \\[\r\nV_j(t) = 2\\sqrt{\\Delta\\omega}\\sum_{m=1}^{j}\\sum_{l=1}^{N}|H_{jm}(\\omega_{ml})| cos(\\omega_{ml}t - \\theta(\\omega_{ml}) + \\phi_{ml})\\\\\r\n\\phi_{ml}=rand[0,2\\pi]\\\\\r\n\\theta_{jm}=arctan[\\frac{Im[H_{jm}(\\omega_{ml})]}{Re[H_{jm}(\\omega_{ml})]}]\\\\\r\n\\omega_{ml} = (l-1)\\Delta\\omega + m/n\\Delta\\omega, l=1,2,3,...,N\r\n\\] 注意: 有的文献中将\\(2\\sqrt{\\Delta\\omega}\\)写成\\(\\sqrt{2\\Delta\\omega}\\)这是错的 注意: 如果\\(S(w)\\)为实正定矩阵,则\\(H(w)\\)也为实矩阵,因此\\(\\theta_{jm}=0\\)\r\n实际上, 在采用双索引算法时,并非\\(H(\\omega_{ml})\\)矩阵中的所有元素都将用于最终的谐波叠加. 保留\\(H(\\omega_{ml}\\)矩阵中用到的元素, 组成如下有效元素矩阵\r\n\\[\r\nH^{eff}(w) = \\begin{bmatrix} H_{11}(\\omega_{1l}) &amp;  0 ...  &amp; 0 \\\\\r\nH_{21}(\\omega_{1l}) &amp;  H_{22}(\\omega_{2l})  ...  &amp; 0 \\\\\r\n. &amp; ........ &amp; . \\\\\r\n. &amp; ........ &amp; . \\\\\r\nH_{n1}(\\omega_{1l}) &amp; H_{n2}(\\omega_{2l})  ...  &amp; H_{nn}(\\omega_{nl}) \\\\\\end{bmatrix}\r\n\\]\r\n采用这种方式合成脉动风速需要多次累加计算, 模拟非常耗时, 尤其是当模拟点数较多时\r\nStep 4 (option 3):  采用FFT技术加速风速时程的合成\r\n公式都是自己推导的, 应该没有问题 实际计算过程中发现整个模拟过程中合成风速时程是比较耗时的, 而采用FFT技术可以显著提升模拟速度 \\[\r\nV_j(t) = 2\\sqrt{\\Delta\\omega}\\sum_{m=1}^{j}\\sum_{l=1}^{N}|H_{jm}(\\omega)| cos(\\omega_{ml}t - \\theta(\\omega_{ml}) + \\phi_{ml})\\\\\r\n\\]\r\n引入欧拉公式\\(e^{ix} = cosx + isinx\\),且\\(\\theta_{jm}(\\omega_{wl}=0\\), 上式可以改写为 \\[\r\nV_j(t) = 2\\sqrt{\\Delta\\omega}\\sum_{m=1}^{j}\\sum_{l=1}^{N}|H_{jm}(\\omega_{ml})| Re[e^{i(\\omega_{ml}t + \\phi_{ml})}]\\\\\r\n= Re[2\\sqrt{\\Delta\\omega}\\sum_{m=1}^{j}\\sum_{l=1}^{N}|H_{jm}(\\omega_{ml})| e^{i\\omega_{ml}t} e^{i\\phi_{ml}}]\\\\\r\n=Re[\\sum_{m=1}^{j}(\\sum_{l=1}^{N} 2 \\sqrt{\\Delta\\omega} |H_{jm}(\\omega_{ml})| e^{i\\omega_{ml}t} e^{i\\phi_{ml} })]\r\n\\]\r\n代入\\(\\omega_{ml} = (l-1)\\Delta\\omega + \\frac{m}{n}\\Delta\\omega\\), 上式可以改写为 \\[\r\nV_j(t) = Re[\\sum_{m=1}^{j}(\\sum_{l=1}^{N} 2 \\sqrt{\\Delta\\omega} |H_{jm}(\\omega_{ml})| e^{i((l-1)\\Delta\\omega + \\frac{m}{n}\\Delta\\omega)t} e^{i\\phi_{ml} })]\\\\\r\n=Re[\\sum_{m=1}^{j}(\\sum_{l=1}^{N} 2 \\sqrt{\\Delta\\omega} e^{i\\phi_{ml}} |H_{jm}(\\omega_{ml})| e^{i((l-1)\\Delta\\omega t} )e^{i\\frac{m}{n}\\Delta\\omega t} ]\\\\\r\n= Re[\\sum_{m=1}^{j}G_{jm}(p\\Delta t) e^{i\\frac{m}{n} \\Delta \\omega t}]\r\n\\]\r\n注意, 上式中括号内部分刚好是离散傅里叶逆变换的表达式 \\[\r\nG_{jm} = (\\sum_{l=1}^{N} 2 \\sqrt{\\Delta\\omega} e^{i\\phi_{ml}} |H_{jm}(\\omega_{ml})| e^{i(l-1)\\Delta\\omega t} )\\\\\r\n\\]\r\n令\\(k = l - 1, (k=0,1,2,...,N-1)\\) 且 , \\(B_{jm} = 2 \\sqrt{\\Delta\\omega} e^{i\\phi_{ml}} |H_{jm}(\\omega_{ml})|, \\Delta\\omega=\\frac{\\omega}{N}=\\frac{2\\pi f}{N}\\),上式可以改写为 \\[\r\nG_{jm}(p\\Delta t) = (\\sum_{l=1}^{N}B_{jm} e^{ik\\Delta\\omega t} ) = (\\sum_{k=0}^{N-1}B_{jm} e^{i k \\Delta \\omega p\\Delta t} )\r\n\\]\r\n信号的最长周期\\(T_0 = \\frac{2\\pi}{\\Delta \\omega}\\), 若采样时间间隔为\\(\\Delta t\\), 一个周期内的时间点数为\\(M = \\frac{T_0}{\\Delta t}\\), 则 \\[\r\nT_0 = M \\Delta t = \\frac{2 \\pi}{\\Delta \\omega}\\\\\r\n\\Delta t \\Delta \\omega = \\frac{2 \\pi}{M}\r\n\\] 带入上上式中 \\[\r\nG_{jm}(p\\Delta t) = (\\sum_{l=1}^{N}B_{jm} e^{ik\\Delta\\omega t} ) = (\\sum_{k=0}^{M-1}B_{jm} e^{i kp \\frac{2\\pi}{M}})\\\\\r\nB_{jm} = \\left \\{ \r\n\\begin{aligned}\r\n2 \\sqrt{\\Delta\\omega} e^{i\\phi_{ml}} |H_{jm}(\\omega_{ml})|, 0 \\leq l &lt; N \\\\\r\n0,  N \\leq &lt; l &lt;M\r\n\\end{aligned}\r\n\\right.\r\n\\] 而离散傅里叶逆变换的表达式为\\(x(t) = \\frac{1}{N} \\sum_{n=0}^{N-1} X(n) e^{i\\frac{2 \\pi}{N} t n}\\) 因此, 可以对\\(B_{jm}\\)进行离散傅里叶逆变换从而提高运算效率, (FFT的时间复杂度为\\(nlog(n)\\)).\r\n说明1: 在很多文献中对这部分都描述为使用FFT技术加速计算, 然而并未提及到底是使用fft还是ifft; 另一方面在网络上看到的很多代码中, 都是直接使用fft进行计算的. 然而, 依据上述推导过程及表达式, 显然应该使用ifft才比较合理; 另一方面, 从物理意义上看, ifft是将信号从频域转换到时域, 和\\(B_{jm}转换到G_{jm}\\)这个过程也是吻合的. 此外, 为了验证采用ifft的正确性, 对比了直接采用Deodatis双索引公式合成的脉动风和采用ifft合成的脉动风速的时程和频谱, 结果表明二者完全一致, 这足以说明采用ifft的正确性.\r\n说明2: 在很多文献3中\\(p \\Delta t, p=0,2,3,..., M*npts-1\\) 生成风速的总时长都为\\(T=nT_0=npts*M*\\Delta t\\), 我没搞懂这个是怎么来的? 在我推导的表达式中, 模拟时长\\(T=T_0\\)与模拟点数\\(npts\\)并无关系, 实际模拟的结果无论是总能量还是频谱分布都吻合, 所以这个为啥这么做?\r\n\r\nStep 5 (option 1): 平稳信号模拟的误差分析\r\n完成全部模拟后, 应当对生成的信号进行误差分析, 以此判断模拟结果的精度, 误差分析应当包含如下几部分内容\r\n\r\n模拟谱与目标谱的对比, 能量分布应当吻合\r\n\r\n\r\n绘制模拟谱与目标谱的对比图片\r\n\r\n\r\n验证模拟信号是否满足各态历经性\r\n参考文献4\r\n根据维纳-辛钦定理, 平稳随机过程的功率谱密度与自相关函数满足如下关系(fft变换): \\[\r\nFFT: S(\\omega) = \\int_{-\\infty}^{\\infty} R(\\tau) e^{-i \\omega \\tau} d\\tau\\\\\r\nIFFT: R(\\tau) = \\frac{1}{2\\pi} \\int_{-\\infty} ^{\\infty} S(\\omega) e^{i \\omega \\tau} d\\omega\r\n\\]\r\n\r\n自/互相关函数对比\r\n\r\nensemble auto-/cross-correlation function \\[\r\nR_{jk}^{0} (\\tau) = R_{jk} (\\tau) = \\int_{-\\infty}^{\\infty} {S_{jk}^{0} (\\omega) e^{i\\omega \\tau} d\\omega}\r\n\\] temporal auto-/cross-correlation fuction \\[\r\nR_{jk}^{i}(\\tau) = \\frac{2} {T_0} \\Delta \\omega \\sum_{m=1} ^{n} \\sum_{l=0} ^{N-1} |H_{jm}(\\omega_{ml})||H_{km}(\\omega_{ml})| cos(\\omega_{ml} \\tau - \\theta_{jm}(\\omega_{ml}) + \\theta_{km}(\\omega_{ml}))\\\\\r\nR_{jk}^{i}(\\tau) =E[V_j(t) V_k(t + \\tau)], j, k = 1, 2, 3, ..., n.\r\n\\]\r\n相干函数的对比, 空间相关性应该吻合\r\n\r\n相干函数的计算\r\n\r\n\\[\r\n\\gamma(w) = \\frac{|S_{ij}(\\omega)|}{\\sqrt{S_{i}(\\omega)S_j(\\omega)}}\r\n\\]\r\n将上述公式计算的模拟信号之间的相干函数与目标相干函数之间进行对比\r\n\r\n注意: 上述比较都是通过比较二者之间的差距进行了, 实际上并没有一个精确的误差度量函数, 或许可以以后提出一个能够衡量随机信号模拟误差的函数\r\nStep 5 (option 2): 非平稳信号的误差度量\r\n\r\n\r\n尚未完成\r\n\r\n关于一些参数的选择\r\n关于模拟时间间隔\\(\\Delta t\\)的选取\r\n主要参考文献: (张军锋)5\r\n频率点数\\(N\\)的选取原则\r\n若模拟时将频率划分为\\(N\\)等份,则合成脉动风场时的频率分辨率为\\(\\Delta\\omega=\\omega_u/N\\). 显然,\\(N\\)越大, \\(\\Delta\\omega\\)越小, 模拟结果越精确, 根据Shinozuka6的研究当\\(N&gt;1000\\) 之后模拟结果已经足够精确. (需要说明的是, 这个值显然需要考虑\\(\\omega_u\\)的大小, \\(N\\)的选取原则还是以\\(\\Delta\\omega\\)足够小来控制). \\(N\\)越大意味着频率分辨率越高, 结果越能反应目标谱的频率分布特征, 然而\\(N\\)越大, 需要进行cholesky分解的次数就越多, 合成风速时程的运算量也会相应增加, 模拟越耗时.\r\n另一方面, 频率点数\\(N\\)对模拟结果的影响直接体现在结果的统计特征上, 下表给出了改变\\(N\\)时, 生成信号的均值和标准的变化. 同时也给出了功率谱\r\nTable1. 均值随\\(N\\)的变化\r\n\r\n\r\n\r\nz/m\r\n\\(N=2048, M=8192\\)\r\n\\(N=4096\\)\r\n\\(N=8192, M=16384\\)\r\n\\(N=2048, M=16384\\)\r\n\r\n\r\n\r\n\r\n10\r\n-0.66821262\r\n-0.3449268\r\n-0.16279961\r\n-0.66799636\r\n\r\n\r\n20\r\n-0.56113631\r\n-0.37252204\r\n-0.16406671\r\n-0.5607632\r\n\r\n\r\n30\r\n-0.57451271\r\n-0.36096364\r\n-0.14268815\r\n-0.57402902\r\n\r\n\r\n40\r\n-0.6081656\r\n-0.38176085\r\n-0.14132875\r\n-0.60777049\r\n\r\n\r\n50\r\n-0.60592006\r\n-0.38206021\r\n-0.14138088\r\n-0.60559317\r\n\r\n\r\n\r\nTable1. 标准差随\\(N\\)的变化\r\n\r\n\r\n\r\nz/m\r\n\\(N=2048, M=8192\\)\r\n\\(N=4096\\)\r\n\\(N=8192, M=16384\\)\r\n\\(N=2048, M=16384\\)\r\n\r\n\r\n\r\n\r\n10\r\n3.87999986\r\n4.06380318\r\n4.1359681\r\n3.88004574\r\n\r\n\r\n20\r\n3.63991524\r\n4.17707677\r\n4.27935855\r\n3.63988511\r\n\r\n\r\n30\r\n3.77922552\r\n4.2882123\r\n4.29608268\r\n3.77915903\r\n\r\n\r\n40\r\n3.86934391\r\n4.26617434\r\n4.24411591\r\n3.86924546\r\n\r\n\r\n50\r\n3.91308826\r\n4.25154157\r\n4.28752741\r\n3.91299012\r\n\r\n\r\n\r\n\r\nFig.3 \\(N = 2048, M=16384\\)\r\n\r\nFig.4 \\(N = 4096, M=16384\\)\r\n\r\nFig.5 \\(N = 8192, M=16384\\)\r\n从Table1和Table2中可以看出, 随着\\(N\\)增加生成信号的均值逐渐趋于0, 标准差也逐渐趋于稳定; 而改变时间点数\\(M\\)对模拟结果影响非常小. 从频谱图中可以看出, 对于本算例, \\(N &gt; 2048\\)后, \\(N\\)基本不影响功率谱的模拟.\r\n考察合成公式 \\[\r\nV_j(t) = 2\\sqrt{\\Delta\\omega}\\sum_{m=1}^{j}\\sum_{l=1}^{N}|H_{jm}(\\omega)| cos(\\omega_{ml}t - \\theta(\\omega_{ml}) + \\phi_{ml})\\\\\r\n\\] 谐波合成法的本质是以功率谱密度为加权系数, 通过一系列余弦信号的叠加来模拟脉动风速. 而实际过程中, 功率谱在频域内被离散为一系列频率点处的取值, 然后以离散的功率谱去逼近连续的功率谱, 在这个过程中不可避免的会产生误差. 具体就体现在, 生成的脉动风速时程的均值不为0. 本程序建议先通过试算生成信号的湍流强度\\(I_u\\)是否满足要求, 以此作为\\(N\\)的取值参考. 同时, 本程序中也会强制将生成信号的均值置为0, 使用时请务必注意.\r\n时间点数\\(M\\)的选取原则\r\n采用WAWS生成的脉动风场可以理解为一个模拟信号\\(V_j(t)\\)(该信号在时间上连续的), 这个信号的频率上限为\\(\\omega_{u}\\), 包含\\(n\\omega_{u}/N, n=0,1,2,...,N\\)个频率成分. 而最终使用的是从\\(V_j(t)\\)采样得到的离散的数字信号,所以应该遵从采样定理.\r\n根据合成公式, 生成的信号在每个频率点的周期为\\(T_l = 2 \\pi / \\omega_l = 2 \\pi N / l \\omega_u\\), 叠加后的脉动风场也是周期函数, 其中的最长周期为 \\[\r\nT_0 = \\frac{2 \\pi}{\\omega_1} = \\frac{2 \\pi}{\\Delta \\omega} = \\frac{2 \\pi N}{\\omega_u}\r\n\\] 定义\\(M\\)为最长周期内的时间点数量, 即 \\[\r\nT_0 = M \\Delta t = \\frac{2 \\pi} {\\Delta \\omega} = \\frac{2 \\pi N}{\\omega_u}\\\\\r\n\\Delta t = \\frac{2 \\pi} {\\Delta \\omega M} = \\frac{2 \\pi N}{\\omega_u M} = \\frac{1}{a} \\frac{2 \\pi}{\\omega_u}, a =\\frac{M}{N}\r\n\\]\r\n根据采样定理, 为了避免频率混叠, 从\\(V_{j}(t)\\)采样的采样频率必须满足如下关系 \\[\r\nf_{s} \\geq 2 f_{u} = 2 \\frac{\\omega_{u}}{2\\pi}=\\frac{\\omega_{u}}{\\pi}\r\n\\] 因此 \\[\r\n\\Delta t = \\frac{1}{f_s} \\leq \\frac{\\pi}{\\omega_u}\r\n\\] 注意:WAWS生成的模拟信号所包含的最高频率成分也仅为\\(\\omega_u\\), 采样得到的数字信号中的频率成分为\\([0, \\frac{f_s}{2}]\\), 而其中高于\\(\\omega_u=2\\pi f_u\\)的部分都是虚假的(无效的)\r\n模拟信号总持时: \\[\r\nT_0 = M \\Delta t\r\n\\] 根据上述公式, \\(\\Delta t\\)的选取只要满足采样定理就一定能保证生成的脉动风的功率谱密度与目标谱一致. 然而, 考虑到模拟的脉动风速时程主要用于结构动力时程分析, 因此\\(\\Delta t\\) 的选择还应该考虑是否会影响结构计算的精度, 张军锋7针对这个问题进行了研究, 在此只给出他的研究结论:\r\n\r\n\\(M/N \\geq 2\\)后, \\(M/N\\)比值并不影响生成的脉动风功率谱密度与目标谱的一致性;但对应的\\(\\Delta t\\)可能在动力时程计算中无法准确计入结构的共振响应,尤其当需要计及的结构频率在\\(\\omega_u\\)附近时. 且如果\\(\\Delta t\\)过大, 即使在动态时程分析时增加荷载子步(阶跃荷载或线性插值,原文采用ANSYS进行分析)也无法准确计入共振效应,必须减小模拟脉动风的采样间隔\\(\\Delta t\\)\r\n对单自由度系统而言, 当\\(M/N \\geq 8\\)之后, 通过模拟风速时程计算的系统响应与理论解非常接近, 可以作为\\(M/N\\)取值的参考; 单自由度弹簧振子模型对\\(\\Delta t\\)的要求最为苛刻, 可以作为普通结构的上限\r\n\r\n模拟中时频参数选取建议和实施步骤\r\n根据上述分析, 关于\\(M, N\\)的选取可以按照如下步骤执行\r\n\r\nStep 1: 合理确定周期\\(T_0\\)(模拟风速总时长\\(T\\)), 一般有\\(T_0 \\geq T = 600 s\\)\r\n\r\n通过WAWS生成的脉动风荷载主要用于结构的抖振分析, 因而10min以上的平均才具有统计意义\r\n对于非平稳风场,还需了解更多文献\r\n\r\nStep 2: 确定截止频率上限\\(\\omega_u = 2 \\pi f_u\\), \\(f_u \\geq f_{struct}\\)\r\n\r\n\\(f_{struct}\\)为所关心的结构频率. 如对输电塔而言, \\(f_{struct}\\)可以取1阶扭转频率, 但如果需要计入高阶模态的影响,则应该考虑更高阶模态频率\r\n\r\nStep 3: 确定频率点\\(N\\), 通常可以取 \\(N = 1024\\) 或\\(N=2048\\) (确保\\(N &gt;1000\\))\r\n\r\n注意\\(N\\)越大模拟越精确,但是也更耗时\r\n\\(N\\)将直接影响生成的脉动风速时程的均值和方差, 建议先通过试算生成信号的湍流强度\\(I_u\\)是否满足要求, 以此确定\\(N\\)的取值\r\n频率点数\\(N\\)直接影响生成的脉动风信号的最长周期\\(T_0=\\frac{2 \\pi N}{\\omega_u}\\) , 因此选择\\(N\\)需要考虑到\\(T_0 &gt; T\\)\r\n\r\nStep 4: 确定模拟时间点, 可以取\\(M = 8N\\)(确保\\(M\\geq2N\\))\r\n\r\n按照上述步骤确定相关参数取值后: \\[\r\n\\Delta \\omega = \\frac{\\omega_u}{N} \\\\\r\n\\Delta t = \\frac{T_0}{M}\r\n\\] ### 关于角频率$\\(和频率\\)f$, 频谱, 功率谱等\r\n角频率或称圆频率\\(\\omega (rad/s)\\)与频率\\(f (Hz)\\)之间存在如下关系: \\[\r\n\\omega = 2 \\pi f\r\n\\] 如果输入的风谱和相干函数为频率的函数,即\\(S(f), coh(f)\\), 那么经过cholesky分解后得到的下三角矩阵也应该为频率的函数\\(H(f)\\), 因而在合成脉动风速时, 应该按照频率进行叠加 \\[\r\nV_j(t) = 2\\sqrt{\\Delta f}\\sum_{m=1}^{j}\\sum_{l=1}^{N}\\lvert H_{jm}(f) \\rvert cos(\\omega_{ml}t - \\theta(\\omega_{ml}) + \\phi_{ml})\r\n\\] 而\\(\\Delta f = \\Delta \\omega / (2\\pi)\\)\r\n另一方面, 如果输入的风谱和相干函数为角频率的函数,即\\(S(w), coh(w)\\), 那么采用则完全按照角频率的公式进行计算. 然而需要注意的是, 对生成的脉动风信号进行频谱分析时(采用scipy.signal.welch), 得到的是S(f); 而目标谱则为\\(S(w)\\), 进行比较时需将二者统一.\r\n两种频率表示的频谱\\(F(\\omega)\\)和\\(F(f)\\)\r\n若存在随机信号\\(f(t), t\\in (-\\infty, \\infty)\\) 满足狄氏条件(信号存在傅里叶变换的充分不必要条件), 且绝对可积 \\[\r\n\\int_{-\\infty}^{\\infty}|f(t)|dt &lt; \\infty\r\n\\] \\(f(t)\\)的傅里叶逆变换为 $$ f(t) =  {-}{}F()e{jt}d= {-}^{}F(f) e^{j2ft}df \\\\\r\n傅里叶变换:\\\\ F() = {-}{}f(t)e{-jwt}dt \\ F(f) = {-}^{}f(t) e^{-j2ft}dt $$ 可以发现, 信号\\(f(t)\\)的频谱用\\(\\omega\\)和\\(f\\)表示时存在一个压缩关系, 相差\\(2\\pi\\)倍, 即\\(F(\\omega)\\)和\\(F(f)\\)并不相等\r\n两种频率表示的功率谱密度\\(P(\\omega)\\)和\\(P(f)\\)\r\n从能量角度出发(信号满足Parseval定理), 信号在一个周期内的总能量如下 \\[\r\nE_T = \\int_{-\\infty}^{\\infty}f^2(t)dt = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty}|F(\\omega)|^2d\\omega = \\int_{-\\infty}^{\\infty}|F(f)|^2df\r\n\\] 上式的含义是, 信号在时域内的能量与频域内的能量相等\r\n那么一个周期内的平均功率如下 \\[\r\nP = \\lim\\limits_{T\\to\\infty} \\int_{-T/2}^{T/2} \\frac{1}{T} f^2(t)dt = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} \\lim\\limits_{T\\to\\infty} \\frac{1}{T}|F(\\omega)|^2d\\omega = \\int_{-\\infty}^{\\infty} \\lim\\limits_{T\\to\\infty} \\frac{1}{T} |F(f)|^2df\r\n\\] \\(f(t)\\)的功率谱 \\[\r\nP(\\omega) = \\lim\\limits_{T\\to\\infty} \\frac{|F(\\omega)|^2}{2\\pi T} \\\\\r\nP(f) = \\lim\\limits_{T\\to\\infty} \\frac{|F(f)|^2}{T}\r\n\\] 注意: \\(P(\\omega)\\)与\\(P(f)\\)并不相等 \\[\r\nP = \\int_{-\\infty}^{\\infty}P(\\omega)d\\omega = \\int_{-\\infty}^{\\infty} P(f)df\\\\\r\nP(f) = 2\\pi P(\\omega)\r\n\\] \r\n\\[PSD = \\lim_{T\\to\\infty}\\frac{E[|\\hat{f_{T}}(\\omega)|^2]}{2T}\\]\r\n正如示意图所示, 同一信号的功率谱密度\\(P(f)\\)和\\(P(\\omega)\\)所蕴含的总能量应该是相等的\r\n另一方面从相关关系的角度也能得出相同的关系 \\[\r\nP(\\omega) = \\frac{1}{2\\pi} \\int Rxx(\\tau) e^{-j\\omega \\tau} d\\tau \\\\\r\nP(f) =\\int Rxx(\\tau) e^{-j2\\pi f\\tau} d\\tau \\\\\r\nP(f) = 2\\pi P(\\omega)\r\n\\] 也即是说\\(P(f)\\)与\\(P(\\omega)\\)不是同一个函数, 为了方面理解可以改写为\\(P_f(f)\\)和\\(P_{\\omega}(f)\\). 同理, 对于风速谱\\(S(f)\\)与\\(S(\\omega)\\)也存在相同的关系. 实际工程中通常将风速谱表示为物理频率\\(f\\)的函数, 如Davenport谱 \\[\r\n\\frac{f S_f(f)} {\\sigma_u^2} = \\frac{2x^2}{3(1 + x^2)^{\\frac{4}{3}}}\\\\\r\nx = \\frac{fL_u}{\\bar{v}}\\\\\r\nL = 1200 m\r\n\\] 上式中, 可以用\\(\\omega=2\\pi f\\)进行替换得到\\(S_f(\\omega)\\), 但需要注意得到的函数\\(S_f(\\omega)\\)并不等于\\(S_{\\omega}(\\omega)\\), 二者还存在一个\\(2\\pi\\)的系数, 两者之间的真实关系如下 \\[\r\nS_f(f)=S_f(\\omega) = 2\\pi S_{\\omega}(\\omega)\r\n\\]\r\n单边谱与双边谱\r\n现实世界不存在负频率 \\[\r\nP_{oneside}(\\omega) = 2P_{twoside}(\\omega)\r\n\\]\r\n程序中关于风谱的使用说明\r\n\r\n风工程中的风谱多表示成物理频率\\(f\\)的函数, 因此本程序编写的风谱函数均为\\(S_f(f)\\), 在使用自编的风谱函数时,请务必注意\r\n风谱函数\\(S_f(f)\\)为单边谱, 而在生成互谱密度矩阵时采用的是双边谱, 因此需要\\(S_f(f)/2\\)\r\n考虑到上述谐波合成法理论中, 风谱均表示为角频率\\(\\omega\\)的函数, 因此在GustWindField class中将输入的目标功率谱\\(S_f(f)\\)转换为\\(S_{\\omega}(\\omega)\\)\r\n为了减少计算量, 按照风谱函数计算的目标将存储在target属性中, 对比生成信号功率谱和目标功率谱一致性时, 将直接调用这个数据\r\n生成信号的功率谱采用welch方法计算(scipy.singal.welch), 得到的结果是\\(S_v(f)\\); 因此将target中存储的数据转换后进行对比, 具体方法为: 横坐标\\(f=\\omega/(2\\pi)\\), 纵坐标: \\(S_v(f) = target * 2 \\pi\\); (具体原理见2.2节)\r\n\r\nWAWS合成法的加速\r\n根据文献8Deodatis引入双索引频率的目的在于减小模拟样本的周期性, 同时可以实现生成的脉动风场的各态历经性. 从下面的表达式可以看出, 如果 \\[\r\nV_j(t) = 2\\sqrt(\\Delta \\omega) \\sum_{m=1}^{j} \\sum_{l=1}^{N}|H_{jm}(\\omega_{l})cos(\\omega_l t + \\theta_{jm}(\\omega_l) + \\phi_{ml})\\\\\r\n\\omega_l = l\\Delta\\omega, l = 1,2,3,...,N\r\n\\] 然而引入双索引频率\\(\\omega_{ml}, m=1, 2, ..., npts; l = 1, 2, 3, ..., N\\)后, cholesky分解的运算量将从\\(N\\)次陡增到\\(npts \\times N\\)次.\r\ncholesky分解算法的最优时间复杂度为\\(o(n^3)\\),\\(n\\) 为矩阵维度. 因此当需要模拟的点数较多时, 整个算法将变得非常耗时. 为了提升WAWS的计算效率, 一些加速算法被相继提出来, 这些算法主要分为两类, 一类是对\\(H(\\omega)\\)进行插值, 从而达到减少cholesky分解次数的目的; 另一类是对\\(S_{ij}(\\omega)\\)矩阵进行降维度(主要采用POD算法), 进而合成脉动风荷载. 关于这方面的研究很多9, 本程序暂且没有考虑通过算法优化的方式来加速计算, 而是直接采用了并行计算来加速\\(H(\\omega)\\)矩阵的分解, 这样做的目的一方面是避免插值或者POD带来的误差, 另一方面是可以充分利用现有的计算资源.\r\nWAWS算法中另一处比较耗时的计算在于脉动风荷载的合成, 尤其是当模拟点\\(npts\\), 频率点\\(N\\)和时间点\\(M\\)都比较多时, 采用ifft算法可以显著降低这部分耗时, 程序中也默认使用这一方法.\r\n风场相关参数的选择\r\n主要参考文献10, 文章中很多关于规范的取值都是基于较早的规范的, (暂时用不上所以没有更新, 欢迎大家更新或者留言)\r\n平均风剖面\r\n本程序仅支持指数律风剖面(且并未留有相关的接口用于改变风剖面的计算, 使用者若想修改请自行阅读和修改源码) \\[\r\n\\bar{v} = \\bar{v}_s (\\frac{z}{z_s}) ^ \\alpha = \\bar{v}_{10} (\\frac{z}{z_{10}}) ^ \\alpha\r\n\\] Table 3. 各国规范中的风剖面指数\\(\\alpha\\)\r\n\r\n\r\n\r\n粗糙度类别\r\nA\r\nB\r\nC\r\nD\r\n\r\n\r\n\r\n\r\n\r\n中国 GB50009-2012\r\n0.12\r\n0.15\r\n0.22\r\n0.30\r\n\r\n\r\n\r\n粗糙度类别\r\nD\r\nC\r\nB\r\nA\r\n\r\n\r\n\r\n美国 ASCE7-95\r\n1/9.0\r\n1/6.5\r\n1/4.0\r\n1/3.0\r\n\r\n\r\n\r\n粗糙度类别\r\nI\r\nII\r\nIII\r\nIV\r\nV\r\n\r\n\r\n日本建筑学会 1993\r\n0.10\r\n0.15\r\n0.20\r\n0.27\r\n0.35\r\n\r\n\r\n\r\nTable 4. 各国规范中的梯度风高度\r\n\r\n\r\n\r\n粗糙度类别\r\nA\r\nB\r\nC\r\nD\r\n\r\n\r\n\r\n\r\n\r\n中国 GB50009-2012 (m)\r\n300\r\n350\r\n450\r\n550\r\n\r\n\r\n\r\n粗糙度类别\r\nD\r\nC\r\nB\r\nA\r\n\r\n\r\n\r\n美国 ASCE7-95 (ft/m)\r\n700/213\r\n900/274\r\n1200/366\r\n1500/457\r\n\r\n\r\n\r\n粗糙度类别\r\nI\r\nII\r\nIII\r\nIV\r\nV\r\n\r\n\r\n日本建筑学会 1993 (m)\r\n250\r\n350\r\n450\r\n550\r\n650\r\n\r\n\r\n\r\n湍流强度\r\n对高耸结构而言, 其抖振响应主要受到湍流强度的影响, 因此在模拟脉动风场时, 应当准确反应湍流强度的基本特征(主要是沿高度的变化). 以下皆为个人理解, 未在文献中看到明确说明: 在模拟风场时, 应当指定湍流强度随高度的变化特征, 然后在计算风谱时应该使得各高度处的风谱满足\\(\\int_0^{\\infty}S_u(\\omega)d\\omega = \\sigma_u^2\\). 在完成风速合成后, 也应该检查生成的风场的湍流强度与指定的湍流强度之间是否吻合.\r\n湍流强度的定义如下 \\[\r\nI_u(z) = \\frac{\\sigma_u(z)}{\\bar{v}(z)}\r\n\\] 式中, \\(\\sigma_u(z)\\)为脉动风速标准差, \\(\\bar{v}(z)\\)为\\(z\\)高度处的平均风速\r\n随着高度的增加, \\(\\sigma_u(z)\\)略有减小, 而平均风速\\(\\bar{v}(z)\\)则递增, 所以湍流强度是随高度增加而减小的. 通常可以表示成如下指数函数 \\[\r\nI_u(z) = c (\\frac{z}{10})^{-d}\r\n\\] 式中, \\(c,d\\)是与地形地貌有关的参数\r\n中国规范中的湍流强度表达式(GB50009-2012) \\[\r\nI_u(z) = I_{10} \\bar{I}_z(z) = I_{10} (\\frac{z} {10}) ^{-\\alpha}\r\n\\] \\(\\alpha\\)为地面粗糙度指数, 按Table 3取值\r\nTable 5. 各国湍流强度特征参数 (\\(c\\), 中国规范中的\\(I_{10}\\))\r\n\r\n\r\n\r\n粗糙度类别\r\nA\r\nB\r\nC\r\nD\r\n\r\n\r\n\r\n\r\n\r\n中国 GB50009-2012, \\(I_{10}\\)\r\n0.12\r\n0.14\r\n0.23\r\n0.39\r\n\r\n\r\n\r\n粗糙度类别\r\nD\r\nC\r\nB\r\nA\r\n\r\n\r\n\r\n美国 ASCE7-95, \\(c\\)\r\n0.15\r\n0.2\r\n0.3\r\n0.45\r\n\r\n\r\n\r\n\\(d\\)\r\n0.167\r\n0.167\r\n0.167\r\n0.167\r\n\r\n\r\n\r\n粗糙度类别\r\nI\r\nII\r\nIII\r\nIV\r\nV\r\n\r\n\r\n日本建筑学会 1993 , \\(c\\)\r\n0.162\r\n0.203\r\n0.259\r\n0.361\r\n0.531\r\n\r\n\r\n\\(d\\)\r\n0.15\r\n0.20\r\n0.25\r\n0.32\r\n0.40\r\n\r\n\r\n\r\n积分尺度\r\n湍流积分尺度是气流中湍流涡旋平均尺寸的量度, 湍流积分尺度的定义如下\r\n\\[\r\nL_u^e = \\frac{1}{\\sigma_u^2} \\int_0^{\\infty} R_{u_1 u_2}(r)dr\r\n\\] 式中, \\(u\\)为顺风向脉动风速分量; \\(\\sigma_u\\)为脉动风速的标准差; \\(R_{u_1 u_2}(r)\\) 为互相关函数; \\(e\\)为与顺风向脉动风速分量有关的旋涡方向, 一共三个, 分别是顺风向, 横风向, 竖向. 同理另外两个脉动风速分量也分别有三个旋涡方向; 也即是湍流积分尺度共有9个.\r\n由于我国规范采用与积分尺度不随高度变化的Davenport谱, 因此没有规定湍流积分尺度的表达式, 其他国家的规范如下\r\n美国ASCE7: \\(L_{\\bar{z}} = l (\\frac{\\bar{z}}{10})^ {\\bar{\\epsilon}}\\), \\(l, \\bar{\\epsilon}\\)取决于地形\r\n日本RLB-AIJ: \\(L_H = 100 (\\frac{H}{30})^{0.5}\\)\r\n脉动风速谱\r\n自然界某一时段内的脉动风速可以用平稳随机过程来模拟，因此脉动风功率谱就成为表达脉动风速特性的主要方式. 采用WAWS合成脉动风速时程时, 最重要的参数便是风谱.\r\n目前各国规范中主要采用的顺风向风速谱如下:\r\n\r\nDavenport谱\r\n\r\n\\[\r\n\\frac{n S_u(n)} {\\sigma_u^2} = \\frac{2x^2}{3(1 + x^2)^{\\frac{4}{3}}}\\\\\r\nx = \\frac{nL_u}{\\bar{v}_{10}}\\\\\r\nL = 1200 m\r\n\\]\r\nDavenport谱假定湍流积分尺度\\(L\\)不随高度改变, 取为1200m, 中国规范采用Davenport谱.\r\n\r\nKaimal谱\r\n\r\n\\[\r\n\\frac{n S_u(n)} {\\sigma_u^2} = \\frac{a_1 x}{(1 + a_2 x)^{\\frac{5}{3}}}\\\\\r\nx = \\frac{nL_u}{\\bar{v}}\\\\\r\nl_{\\bar{z}} = l (\\frac{\\bar{z}}{10})^{\\bar{\\epsilon}}\r\na_1 = 6.868, a_2 = 10.302\r\n\\] 美国规范采用该谱, 欧洲规范也采用该谱\r\n\r\n\r\n\r\n地形\r\nA\r\nB\r\nC\r\nD\r\n\r\n\r\n\r\n\r\n\\(l (ft)\\)\r\n54.864\r\n97.536\r\n152.400\r\n198.120\r\n\r\n\r\n\\(\\epsilon\\)\r\n1/0.6096\r\n1/0.9144\r\n1/1.5240\r\n1/2.4384\r\n\r\n\r\n\r\n注：美国规范中地形类别的 A、 B、 C、 D，分别对应着我国规范中的 D、 C、 B、 A 类别\r\n\r\nVon Karman谱\r\n\r\n\\[\r\n\\frac{n S_u(n)} {\\sigma_u^2} = \\frac{4x}{(1 + 70.8 x^2)^{\\frac{5}{6}}}\\\\\r\nx = \\frac{nL_u}{\\bar{v}}\\\\\r\nL_u = L_H = 100 (\\frac{H}{30})^{0.5}\r\n\\]\r\n日本规范采用该谱\r\n\r\nHarris谱\r\n\r\n\\[\r\n\\frac{n S_u(n)} {\\sigma_u^2} = \\frac{0.6x}{(2 + x^2)^{\\frac{5}{6}}}\\\\\r\nx = \\frac{nL_u}{\\bar{v}}\\\\\r\nL = 1800 m\r\n\\]\r\n澳大利亚规范采用该谱\r\n\r\nSimiu谱 不保证对, 请自行核实\r\n\r\n\\[\r\n\\frac{n S_u(n)} {\\sigma_u^2} = \\left \\{\r\n\\begin{aligned}\r\n\\frac{100x}{3(1 + 50 x)^{\\frac{5}{3}}}, x \\leq 0.2\\\\\r\n\\frac{0.0433}{x ^{2/3}}, x &gt; 0.2\\\\\r\n\\end{aligned}\r\n\\right. \\\\\r\nx = \\frac{nz}{\\bar{v}}\\\\\r\n\\]\r\n理想的谱形式应该满足以下三个条件: \\[\r\n条件1\\quad \\int_0^{\\infty} \\frac{S_u(n)}{\\sigma_u^2} dn = 1 \\\\\r\n条件2\\quad S_u(0) = 4 \\sigma_u^2 \\frac{L_u}{\\bar{v}} \\\\\r\n条件3\\quad \\frac{n S_u(n)} {\\sigma_u^2} = A (\\frac{nL_u}{\\bar{v}})^{-2/3}, A=0.10~0.15\\\\\r\n\\]\r\n条件1为必要条件, 可以保证脉动风速的方差等于曲线\\(S_u(n)\\)所覆盖的面积, 并与湍流强度相容; 条件2可以通过自相关函数和谱密度之间的维纳-辛钦关系得到. 条件3要求高频部分满足该式的形式, 主要和结构响应有关\r\n总体来说, Davenport谱和Harris谱不随高度变化, Von Karman谱和Kaimal谱考虑了湍流积分尺度随高度的变化. Davenport谱的谱值偏大, 可能会过高的轨迹结构的抖振响应, 致使计算结果偏于保守. Von Karman 谱是一种理想的形式, 只有它满足上述3个条件11. ben\r\n空间相关性\r\n相干函数定义如下 \\[\r\n\\rho_{xy} (\\omega) = \\frac{S_{xy}(\\omega)}{\\sqrt{S_x(\\omega)S_y(\\omega)}}\\\\\r\n0 \\leq \\rho_{xy}(\\omega) \\leq 1\r\n\\]\r\n\r\nDavenport相关函数\r\n\r\n\\[\r\n\\rho(n) = exp[\\frac{-n \\sqrt{c_x^2 (x_1 - x_2)^2 + c_z^2 (z_1 - z_2)^2}}{\\bar{v}_1 \\bar{v}_2}]\\\\\r\nc_x = 8, c_z = 7\r\n\\]\r\n\r\nShiotani相关函数 - 与频率无关 \\[\r\n\\rho_z = exp[\\frac{-|z_1 - z_2|} {60}]\\\\\r\n\\rho_x = exp[\\frac{-|x_1 - x_2|} {50}]\\\\\r\n\\] 我国建筑结构荷载规范(GB50009-2012)采用改相关函数\r\n\r\n本程序中暂时只实现了Davenport相关函数\r\n风场相关参数的选择建议\r\n总体原则: \r\n\r\n选择风场相关参数时, 可以根据需要使用的规范来确定相关参数的取值\r\n鉴于本人的需求, 目前只简单的实现了风谱的自定义功能, 即用户可以根据自己的需求编写风谱函数, 然后在模拟时调用. 其他参数都是直接在GustWindField clas内部集成, 用户如果需要使用其他自定义参数, 需要自行在源码中修改\r\n本人目前只需要用到中国规范, 因此只能保证程序中关于中国规范的参数是正确的, 其余的参数还请使用者自行检查\r\n\r\n补充:目前关于自定义风谱的实现非常粗略, 采用的是eval()函数, 以后应该会修改为直接传递风谱(或其他)函数作为参数, 从而实现自定义参数的输入\r\n一些细节:\r\n\r\n平均风剖面: 仅支持指数律\r\n\r\n需要输入\\(v_{10}\\)和风剖面指数\\(\\alpha\\)两个参数, 见Table 3\r\n\r\n湍流强度\r\n\r\n需要输入\\(I_{10}或(c), d\\)两个参数, 见Table 5\r\n湍流强度沿高度的变化将直接反应到风谱中, 最终生成的风场的湍流强度也应该与输入的湍流强度吻合\r\n\r\n脉动风谱和积分尺度\r\n\r\n前文给出的风谱\\(S(n)\\)都是物理频率\\(n\\)的函数, 本程序在使用时都先转换成了圆频率的函数\\(S(\\omega)\\)(见2.2.4节, \\(\\omega = 2 \\pi n\\))\r\n根据第2条, 在计算风谱时, 将直接给定该高度处的湍流强度值\r\n积分尺度的选择可以按照各风谱的规定进行选择\r\n\r\n空间相关性\r\n\r\n本程序中暂时只能使用davenport 相关函数\r\n\r\n\r\nReferences\r\n\r\n\r\n\r\n(祝志文)↩︎\r\n(杨素珍)↩︎\r\nShinozuka M, Deodatis G. Simulation of stochastic processes by spectral representation[J]. Applied mechanics reviews. 1991, 44(4): 191-204↩︎\r\nShinozuka M, Deodatis G. Simulation of stochastic processes by spectral representation[J]. Applied mechanics reviews. 1991, 44(4): 191-204↩︎\r\n(张军锋)↩︎\r\nShinozuka M, Deodatis G. Simulation of stochastic processes by spectral representation[J]. Applied mechanics reviews. 1991, 44(4): 191-204↩︎\r\n(杨素珍)↩︎\r\n(祝志文)↩︎\r\n 陶天友↩︎\r\n 赵杨↩︎\r\n 赵杨↩︎\r\n\r\n\r\n","categories":["Softwae"]},{"title":"Examples of openVFIFE","url":"/2021/06/13/openVFIFE_examples/","content":"Examples\r\nopenVFIFE is quite simple and intuitive. The basic procedures of a calculation is as follows:\r\n\r\ncreate a StructSystem to manage all struct objects\r\ncreate Particles\r\ncreate Materials and Sections (necessary in bar structures)\r\ncreate Elements\r\nadd constraints\r\nadd external force and solve\r\n\r\nthe pseudocodes for the procesdure\r\n#include &quot;structsystem.h&quot;\t// using openVFIFEStructSystem system = StructSyste(id);\t// create a StructSystem to manage all struct objects// ... system settingPartice* p = new Partice(id, x, y, z);  // create particle objectsystem.addPartice(p);\t\t\t\t   // add particle into systemBaseMaterial mat = LinearElastic(id);   // create Material// ... material settingBaseSection sect = Rectangle(id, width, height);    // create sectionBaseElement* e = new Beam3D(id, p1, p2, mat, sect);\t// create elementsystem.addElement(e);\t\t\t\t\t\t\t  // add element into systemsystem.addConstraint(pid, c);\t\t\t\t\t  // add constraints// time history solvefor (int i = 0; i &lt; nstep; i++)&#123;    if (i == 0)    &#123;        // solve first time step\t\tsystem.addExternalForce(pid, force);\t\t// add external force\t\tsystem.solve(dt, zeta, true);\t\tsystem.setInternalForce();    &#125;    else    &#123;\t\tsystem.solve(h, zeta);\t\tsystem.clearParticleForce();\t\tsystem.setExternalForce(pid, f);\t\tsystem.setInternalForce();    &#125;    // save results    system.saveParticleResult(path);\tsystem.saveElementResult(path);\tsystem.saveSupportReact(path);&#125;system.releaseContainers();\t\t\t\t\t    // relase system containers\r\nAs you can see in the above codes, using openVFIFE to conduct structure analysis is same as other FEM software. To illustrate the using of openVFIFE, several examples are list here. You can learn openVFIFE through these simple examples.\r\nNow, let's ROCK!\r\nExample 1\r\nIn the first example, I want to show you the moving trajectory calculation of a single paritcle, which is in horizontal projectile motion. The mass of the particle is \\(10kg\\), the initial speed is \\(v_0 = 10m/s\\), and the acceleration of gravity \\(g = 9.8 m/s\\). The governing equation of particle is \\[\r\nHorizontal: m\\ddot{x} + c\\dot{x} = 0\\\\\\\\\r\nVertical: m\\ddot{y} + c\\dot{y} = mg\r\n\\] where, \\(c = m \\zeta\\), \\(\\zeta\\) is the damping parameters in openVFIFE. The solution is\r\nif \\(c \\neq 0\\):\r\n\\[\r\nx = \\frac{mv_0}{c} [1 - e^{-\\frac{c}{m}t}]\\\\\\\\\r\nv_x = \\dot{x} = v_0 e^{\\frac{c}{m}t}\\\\\\\\\r\na_x = \\ddot{x} = -\\frac{c}{m}v_0 e^{-\\frac{c}{m}t}\\\\\\\\\r\ny = \\frac{mg}{c}t + \\frac{m^2 g}{c^2}[e^{-\\frac{c}{m}t}-1]\\\\\\\\\r\nv_y = \\dot{y} = \\frac{mg}{c}[1 - e^{-\\frac{c}{m}t}]\\\\\\\\\r\na_y = \\ddot{y} = g e^{-\\frac{c}{m}t}\r\n\\]\r\nelse if \\(c=0\\): \\[\r\nx = v_0 t\\\\\\\\\r\nv_x = \\dot{x} = v_0\\\\\\\\\r\na_x = \\ddot{x} = 0\\\\\\\\\r\ny = \\frac{1}{2} g t^2\\\\\\\\\r\nv_y = \\dot{y} = gt\\\\\\\\\r\na_y = \\ddot{y} = g\r\n\\]\r\nIn openVFIFE, you can solve the problem by the following code(see ./examples/example1/example1.cpp)\r\n#include &quot;../../headers/structsystem.h&quot;using namespace std;int main()&#123;    // create system    StructSystem system = StructSystem(1);    system.setJobname(&quot;Example1&quot;);    double zeta = 0.0;    cout &lt;&lt; &quot;Please enter a damping coefficient(&gt;=0): &quot; &lt;&lt; endl;    cin &gt;&gt; zeta;    // solve parameters    double endTime = 10.0;  // total time, s    double h = 1.0e-3;      // time step, s    double v0 = 10;         // initial velocity, m/s    double mass = 10;       // mass, kg    double g = 9.8;         // acceleration of gravity, m/s-2    // create particles    Particle* p1 = new Particle(1, 0, 0);    system.addParticle(p1);    // set mass properties    StdArray6d m = &#123;mass, mass, 0, 0, 0, 0&#125;;    p1-&gt;setLumpedMass(m);    // activate dof of particle    p1-&gt;activateDof(&quot;Ux&quot;);    p1-&gt;activateDof(&quot;Uy&quot;);    string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/model&quot;;    system.saveModel(path);    int nStep = ceil(endTime / h);    int interval = ceil(0.1/h);    for (int i = 0; i &lt;= nStep; i++)    &#123;        if (i == 0)        &#123;            // set initial velocity and acclerate            StdArray6d v = &#123;v0, 0, 0, 0, 0, 0&#125;;            p1-&gt;setVelocity(v);            system.setAccelerate(0, 9.8, 0);            system.solve(h, zeta, true);        &#125;        else        &#123;            system.solve(h, zeta);            system.clearParticleForce();            system.setAccelerate(0, g, 0); // add external force            system.setInternalForce();        &#125;        // save results        if (i % interval == 0)        &#123;            string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/&quot; +                          to_string(i*h);            system.saveParticleResult(path);        &#125;    &#125;    system.releaseContainers();    return 0;&#125;\r\nand compile this code by\r\n#g++ -static -O3 xx.cpp -L /directory/of/libvfife.a -lvfife -o xx.outg++ -static -O3 projectile.cpp -L ../../library/static -lvfife -o projectile.out\r\nand run it\r\n#time ./xx.outtime ./projectile.out# you will see the following information in terminal########### StructSystem Established! ###########Please enter a damping coefficient(&gt;0): #0#10000#100#./projectile.out  0.00s user 0.01s system 0% cpu 1.392 total\r\nFinally the results of openVFIFE and theroy solution have been compared in the next figures.\r\n\r\n​ (a) (b)\r\n\r\n​ (c) (d)\r\n \r\n​ (e) (f)\r\nFig. 1. Results, (a) \\(x\\), (b) \\(y\\), (c) \\(\\dot{x}\\), (d) \\(\\dot{y}\\), (e) \\(\\ddot{x}\\) (f) \\(\\ddot{y}\\)\r\nwhen \\(\\zeta = \\frac{c}{m}\\) changes from 0.0 to 1.0, openVFIFE always get the right answer. All these examples are trying to tell you how to use openVFIFE, and illustrate as a verification as well. So there will be no detailed commnets on these examples. If you are interested in these examples, just email me.\r\nExample 2\r\nConsider a single bar structure(as shown in the following figure) , the length \\(l = 10m\\), the section area is \\(1m^2\\), Young's modulus \\(E=10^6Pa\\) , mass density \\(\\rho = 10 kg/m^3\\). In this case, I want to show you how to use openVFIFE to solve static problems, and explain the influence of damping coefficient and time step.\r\n\r\nFig.2. You Can Read It\r\nsource code, see ./examples/example2/example2.cpp\r\n#include &quot;../../headers/structsystem.h&quot;using namespace std;int main()&#123;    // create system    StructSystem system = StructSystem(1);    system.setJobname(&quot;example2&quot;);    // setting damping coefficient    double zeta = 0.5;    cout &lt;&lt; &quot;Please enter a damping coefficient(&gt;=0): &quot; &lt;&lt; endl;    cin &gt;&gt; zeta;    // setting time step    double h = 0.0;    cout &lt;&lt; &quot;Please enter a time step(&gt;=0): &quot; &lt;&lt; endl;    cin &gt;&gt; h;    // solve parameters    double endTime = 50.0;    double p = 100;    // create particles    Particle * p1 = new Particle(1, 0, 0);    Particle * p2 = new Particle(2, 10, 0);    system.addParticle(p1);    system.addParticle(p2);    // create material    LinearElastic mat = LinearElastic(1);    mat.setE(1.0E6);    mat.setDensity(10);    // create section    CustomSectionParas paras = &#123;.A=1, .Sy=0, .Sz=0, .SHy=0, .SHz=0,                                .CGy=0, .CGz=0.0, .Iyy=10, .Izz=10, .Iyz=10&#125;;    CustomSection sect = CustomSection(1, paras);    // create elements    Link2D* e = new Link2D(1, p1, p2, &amp;mat, &amp;sect);    system.addElement(e);    // constraints, Ux, Uy, Uz, Rotx, Roty, Rotz    DOF c1 = &#123;.key = &#123;true, true, true, true, true, true&#125;,              .val = &#123;0, 0, 0, 0, 0, 0&#125;&#125;;    DOF c2 = &#123;.key = &#123;false, true, true, true, true, true&#125;,              .val = &#123;0, 0, 0, 0, 0, 0&#125;&#125;;    system.addConstraint(1, c1);    system.addConstraint(2, c2);    // save model    string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/model&quot;;    system.saveModel(path);    system.info();      // print structsystem information    StdArray6d f1 = &#123;100, 0, 0, 0, 0, 0&#125;;\t//(x, y, z, mx, my, mz)    int nStep = ceil(endTime/h);    cout &lt;&lt; nStep &lt;&lt; endl;    int interval = ceil(0.1/h);    for (int i = 0; i &lt;= nStep; i++)    &#123;        if (i == 0)        &#123;            system.addExternalForce(2, f1);            // add external force            system.solve(h, zeta, true);            system.setInternalForce();        &#125;        else        &#123;            system.solve(h, zeta);            system.clearParticleForce();            system.setExternalForce(2, f1);            system.setInternalForce();        &#125;        // save results        if (i % interval == 0)        &#123;            string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/&quot; +                          to_string(i*h);            system.saveParticleResult(path);            system.saveElementResult(path);            system.saveSupportReact(path);        &#125;    &#125;    system.releaseContainers();    return 0;&#125;\r\nwhen \\(\\Delta t = 0.01\\), the axail force of the bar\r\n\r\n\r\n\r\n\\(\\zeta\\)\r\nTarget (N)\r\nopenVFIFE\r\n\r\n\r\n\r\n\r\n0.0\r\n100.0\r\n--\r\n\r\n\r\n0.5\r\n100.0\r\n100.0\r\n\r\n\r\n1.0\r\n100.0\r\n100.0\r\n\r\n\r\n\r\n\r\nFig.3. Axial Force of The Bar\r\nif \\(\\zeta= 0.0\\), the axial force of the bar will not converge (umdamped free vibration); and when \\(\\zeta\\) increased, the answer will finally converge to the static solution, and the larger \\(\\zeta\\) is, the faster convergence is. Besides, \\(\\zeta\\) won't affect the static solution. Hence, for static problems, large \\(\\zeta\\) could be adopted to help converge.\r\nThe critical time step \\[\r\n\\Delta t_{critical} = \\frac{2l}{v_c} = \\frac{2l}{\\sqrt{E/\\rho}}=0.0316s\r\n\\] when \\(\\zeta= 0.5\\), the axail force of the bar\r\n\r\n\r\n\r\n\\(\\Delta t\\)\r\nTarget (N)\r\nopenVFIFE\r\n\r\n\r\n\r\n\r\n0.001\r\n100.0\r\n99.89860658682635\r\n\r\n\r\n0.01\r\n100.0\r\n99.89854111776447\r\n\r\n\r\n0.1\r\n100.0\r\nnan\r\n\r\n\r\n0.5\r\n100.0\r\nnan\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nFig.4. Axial Force of The Bar, (a) \\(\\Delta t = 0.001, 0.01\\), (b) \\(\\Delta t = 0.001, 0.01, 0.1, 0.5\\),\r\nIf \\(\\Delta t &gt; \\Delta t_{critical}\\), the solution will unconverge, hence it is important to assign time step. openVFIFE provides a autoTimeStep() function for setting proper time step automaticly.\r\nExample 3\r\nRef: Ting, E.C., Y. F. Duan, T.Y. Wu. Vector Mechanics of Structure. BeiJing: Science Press, 2012. Chapter 5, example 1\r\n\r\nFig.5. copy from the reference textbook\r\nParameters \\[\r\na = 10 m, b = 5 m;\\\\\r\nP_{\\alpha} = 20 N, P_{\\beta} = 20N;\\\\\r\nE_{\\alpha} = 20000 Pa, E_{\\beta} = 10000 Pa.\r\n\\] Codes: (see ./examples/example3/example3.cpp)\r\n#include &quot;../../headers/structsystem.h&quot;using namespace std;int main()&#123;    // create system    StructSystem system = StructSystem(1);    system.setJobname(&quot;example3&quot;);    // solve parameters    double endTime = 50.0;    double zeta = 0.5;    double h = 0.01;    double p = 100;    // create particles    Particle* p1 = new Particle(1, 0, 0);    Particle* p2 = new Particle(2, 10, 0);    Particle* p3 = new Particle(3, 10, 5);    system.addParticle(p1);    system.addParticle(p2);    system.addParticle(p3);    StdArray6d mass = &#123;10.0, 10.0, 0, 0, 0, 0&#125;;    p2-&gt;setLumpedMass(mass);    // create material    LinearElastic mat1 = LinearElastic(1);    mat1.setE(2.0E4);    LinearElastic mat2 = LinearElastic(2);    mat2.setE(1.0E4);    // create section    CustomSectionParas paras = &#123;.A=1, .Sy=0, .Sz=0, .SHy=0, .SHz=0,                                .CGy=0, .CGz=0.0, .Iyy=10, .Izz=10, .Iyz=10&#125;;    CustomSection sect = CustomSection(1, paras);    // create elements    Link2D* e1 = new Link2D(1, p1, p2, &amp;mat1, &amp;sect);    Link2D* e2 = new Link2D(2, p2, p3, &amp;mat2, &amp;sect);    system.addElement(e1);    system.addElement(e2);    // constraints    DOF c1 = &#123;.key = &#123;true, true, true, true, true, true&#125;,              .val = &#123;0, 0, 0, 0, 0, 0&#125;&#125;;    DOF c3 = &#123;.key = &#123;true, true, true, true, true, true&#125;,              .val = &#123;0, 0, 0, 0, 0, 0&#125;&#125;;    system.addConstraint(1, c1);    system.addConstraint(3, c3);    // save model    string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/model&quot;;    system.saveModel(path);    system.info();      // print structsystem information    StdArray6d f1 = &#123;-20, 0, 0, 0, 0, 0&#125;;    StdArray6d f2 = &#123;-20, 20, 0, 0, 0, 0&#125;;    StdArray6d f3 = &#123;20, 0, 0, 0, 0, 0&#125;;    int nStep = ceil(endTime/h);    cout &lt;&lt; nStep &lt;&lt; endl;    int interval = ceil(0.1/h);    for (int i = 0; i &lt;= nStep; i++)    &#123;        if (i == 0)        &#123;            // add external force            system.addExternalForce(1, f1);            system.addExternalForce(2, f2);            system.addExternalForce(3, f3);            system.solve(h, zeta, true);            system.setInternalForce();        &#125;        else        &#123;            system.solve(h, zeta);            system.clearParticleForce();            // add external force            system.addExternalForce(1, f1);            system.addExternalForce(2, f2);            system.addExternalForce(3, f3);            system.setInternalForce();        &#125;        // save results        if (i % interval == 0)        &#123;            string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/&quot; +                          to_string(i*h);            system.saveParticleResult(path);            system.saveElementResult(path);            system.saveSupportReact(path);        &#125;    &#125;    system.releaseContainers();    return 0;&#125;\r\nAnswer comparison\r\n\r\n\r\n\r\nDescriptions\r\nItems\r\nTarget\r\nopenVFIFE\r\n\r\n\r\n\r\n\r\nsupport reactions\r\n\\(f_{1x} (N)\\)\r\n-20\r\n-20\r\n\r\n\r\n\r\n\\(f_{1y} (N)\\)\r\n20\r\n20\r\n\r\n\r\n\r\n\\(f_{3x} (N)\\)\r\n-20\r\n-20\r\n\r\n\r\n\r\n\\(f_{3y} (N)\\)\r\n20\r\n20\r\n\r\n\r\ndisplacement of particle 2\r\n\\(U_x (m)\\)\r\n0.01\r\n0.00999503\r\n\r\n\r\n\r\n\\(U_y (m)\\)\r\n-0.01\r\n-0.00999004\r\n\r\n\r\nelement axial force\r\n\\(F_{Na} (N)\\)\r\n20\r\n20\r\n\r\n\r\n\r\n\\(F_{Nb} (N)\\)\r\n20\r\n20\r\n\r\n\r\n\r\n\r\nFig.6. time history of displacement of particle 2\r\nYou can compare the results with the refence. I don't want to do it.\r\nExample 4\r\nRef: Ting, E.C., Y. F. Duan, T.Y. Wu. Vector Mechanics of Structure. BeiJing: Science Press, 2012. Chapter 6, example 2\r\n\r\nFig.7. coordinate system and discrete scheme\r\nParameters: \\[\r\nb = 10m,\\\\\r\nm_2 = 6.25 kg, m_4 = m_5 = m_6 = 2.5 kg,\\\\\r\nE_{1} = 1e5Pa, E_2 = 1e4Pa,\\\\\r\nP_2 = 1.0N, P_v = 0.1N.\r\n\\] \\(P_2\\) is always perpendicular to bar 1, and \\(P_v\\) is always keep vertical.\r\ncodes, (see ./examples/example4/example4.cpp)\r\n#include &quot;../../headers/structsystem.h&quot;using namespace std;int main()&#123;    // create system    StructSystem system = StructSystem(1);    system.setJobname(&quot;example4&quot;);    // solve parameters    double endTime = 50.0;  // total time, s    double zeta = 0.5;      // damping coefficient    double h = 0.01;        // time step, s    // create particles    Particle* p1 = new Particle(1, 0.0, 10.0);    Particle* p2 = new Particle(2, 0.0, 0.0);    Particle* p3 = new Particle(3, 10.0, 0.0);    Particle* p4 = new Particle(4, 2.5, 0.0);    Particle* p5 = new Particle(5, 5.0, 0.0);    Particle* p6 = new Particle(6, 7.5, 0.0);    system.addParticle(p1);    system.addParticle(p2);    system.addParticle(p3);    system.addParticle(p4);    system.addParticle(p5);    system.addParticle(p6);    StdArray6d mass2 = &#123;6.25, 6.25, 0, 0, 0, 0&#125;;    p2-&gt;setLumpedMass(mass2);    StdArray6d mass4 = &#123;2.5, 2.5, 0, 0, 0, 0&#125;;    p4-&gt;setLumpedMass(mass4);    p5-&gt;setLumpedMass(mass4);    p6-&gt;setLumpedMass(mass4);    // create material    LinearElastic mat1 = LinearElastic(1);    mat1.setE(1.0E5);    LinearElastic mat2 = LinearElastic(2);    mat2.setE(1.0E4);    // create section    CustomSectionParas paras = &#123;.A=1, .Sy=0, .Sz=0, .SHy=0, .SHz=0,                                .CGy=0, .CGz=0.0, .Iyy=10, .Izz=10, .Iyz=10&#125;;    CustomSection sect = CustomSection(1, paras);    // create elements, flexible link    Link2DLD* e1 = new Link2DLD(1, p1, p2, &amp;mat1, &amp;sect);    Link2DLD* e2 = new Link2DLD(2, p2, p4, &amp;mat2, &amp;sect);    Link2DLD* e3 = new Link2DLD(3, p4, p5, &amp;mat2, &amp;sect);    Link2DLD* e4 = new Link2DLD(4, p5, p6, &amp;mat2, &amp;sect);    Link2DLD* e5 = new Link2DLD(5, p6, p3, &amp;mat2, &amp;sect);    system.addElement(e1);    system.addElement(e2);    system.addElement(e3);    system.addElement(e4);    system.addElement(e5);    // constraints    DOF c1 = &#123;.key = &#123;true, true, true, true, true, true&#125;,              .val = &#123;0, 0, 0, 0, 0, 0&#125;&#125;;    DOF c3 = &#123;.key = &#123;true, true, true, true, true, true&#125;,              .val = &#123;0, 0, 0, 0, 0, 0&#125;&#125;;    system.addConstraint(1, c1);    system.addConstraint(3, c3);    // save model    string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/model&quot;;    system.saveModel(path);    system.info();      // print structsystem information    // get the direction vector of bar1    const Eigen::Vector3d* ex = e1-&gt;ex();    StdArray6d P2 = &#123;0, 0, 0, 0, 0, 0&#125;;    StdArray6d Pv = &#123;0, -0.1, 0, 0, 0, 0&#125;;    int nStep = ceil(endTime/h);    cout &lt;&lt; nStep &lt;&lt; endl;    int interval = ceil(0.1/h);    for (int i = 0; i &lt;= nStep; i++)    &#123;        // update P2        P2[0] = 10 * (*ex)(0);        P2[1] = -10 * (*ex)(1);        if (i == 0)        &#123;            // add external force            system.addExternalForce(2, P2);            system.addExternalForce(4, Pv);            system.addExternalForce(5, Pv);            system.addExternalForce(6, Pv);            system.solve(h, zeta, true);            system.setInternalForce();        &#125;        else        &#123;            system.solve(h, zeta);            system.clearParticleForce();            // add external force            system.addExternalForce(2, P2);            system.addExternalForce(4, Pv);            system.addExternalForce(5, Pv);            system.addExternalForce(6, Pv);            system.setInternalForce();        &#125;        // save results        if (i % interval == 0)        &#123;            string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/&quot; +                          to_string(i);            system.saveModel(path);            system.saveParticleResult(path);            system.saveElementResult(path);            system.saveSupportReact(path);        &#125;    &#125;    system.releaseContainers();    return 0;&#125;\r\n\r\nFig.8. movement of the structure\r\nExample 5\r\nIn example 1, a planar three-bar truss subjected to a load \\(P\\) in the \\(y\\) is analyzed, as shown in Fig.9. The cross-sectional area (\\(A\\)) of bars is \\(1m^2\\); the length (\\(L_{BD}\\) is \\(1m\\); \\(\\ang ADB = \\ang CDB = 45^ \\circ\\). different plastic material models are considered: an ideal elastic-plastic model and an elastic linear hardening model, as shown in Fig.11. The density (\\(\\rho\\)) of the bars is \\(7850kg\\). Young's modulus \\(E\\) is \\(206GPa\\) in the elastic state; the tangent modulus $Et $ is \\(20.6GPa\\) in the plastic state; and the yield stress (\\(\\sigma _y\\)) is \\(235MPa\\).\r\n\r\nFig.9. example 5\r\ncodes, (see ./examples/example5/example5.cpp)\r\n#include &quot;../../headers/structsystem.h&quot;using namespace std;int main()&#123;    // command-line parameters    cout &lt;&lt; &quot;Please enter P: &quot;;    double load_factor;    cin &gt;&gt; load_factor;    // create system    StructSystem system = StructSystem(1);    system.setJobname(&quot;BilinearTruss&quot;);    // solve parameters    double endTime = 100.0;    double h = 1.0e-3;    double zeta = 1;    double length = 1;    double theta = 45.0 / 180 * PI;    // create particles    Particle* p1 = new Particle(1, -length, 0);    Particle* p2 = new Particle(2, 0, 0);    Particle* p3 = new Particle(3, length, 0);    Particle* p4 = new Particle(4, 0, length);    system.addParticle(p1);    system.addParticle(p2);    system.addParticle(p3);    system.addParticle(p4);    // create material    double E = 2.06e11;    double yield_stress = 2.35e8;    double Et = 2.06e10;    double m = 0;    UniBilinear mat = UniBilinear(1, E, Et, yield_stress, m);    mat.setDensity(7850);    // LinearElastic mat = LinearElastic(1);    // mat.setE(E);    // mat.setDensity(7850);    // create section    CustomSectionParas paras = &#123;.A=1.0, .Sy=0, .Sz=0, .SHy=0, .SHz=0, .CGy=0,                                .CGz=0.0, .Iyy=0.01, .Izz=0.01, .Iyz=0&#125;;    CustomSection sect = CustomSection(1, paras);    // create elements    Link2DLD* e1 = new Link2DLD(1, p1, p4, &amp;mat, &amp;sect);    Link2DLD* e2 = new Link2DLD(2, p2, p4, &amp;mat, &amp;sect);    Link2DLD* e3 = new Link2DLD(3, p3, p4, &amp;mat, &amp;sect);    system.addElement(e1);    system.addElement(e2);    system.addElement(e3);    // constraints    DOF c = &#123;.key = &#123;true, true, false, false, false, false&#125;,              .val = &#123;0, 0, 0, 0, 0, 0&#125;&#125;;    for (int i = 1; i &lt;= 3; i++)    &#123;        system.addConstraint(i, c);    &#125;    system.info();    // save model information    string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/model&quot;;    system.saveModel(path);    StdArray6d f &#123;&#125;;    // f[1] = load_factor;    system.addExternalForce(4, f);    system.solve(h, zeta, true);    system.setInternalForce();    int nStep = ceil(endTime / h);    int interval = ceil(1 / h);    for (int j = 0; j &lt;= nStep; j++)    &#123;        system.solve(h, zeta, false);        system.clearParticleForce();        f[1] =  load_factor * (j * 1.0 / nStep);        system.setExternalForce(4, f);        system.setInternalForce();        // save results        if (j % interval == 0)        &#123;            string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/&quot; +                          to_string(f[1]);            system.saveParticleResult(path);            system.saveElementResult(path);            system.saveSupportReact(path);        &#125;    &#125;    system.releaseContainers();    return 0;&#125;\r\n\r\n\r\nFig.10. results comparison\r\nExample 6\r\nTo illustrate the capability of VFIFE in geometric nonlinear analysis, and to test the Link3DLD element, a 24-member shallow dome (as shown in Fig.13) is analyzed by openVFIFE. The topological relationship between elements and particles is depicted in Fig.11, as well as geometry information. The density \\(\\rho\\) of the bars is \\(20lb/in^3\\); Young’s modulus \\(E\\) is \\(10^6ksi\\); and the cross-sectional area (A) of the bars is \\(0.1in^2\\). A concentrated force \\(P\\) is imposed on node 1 in the \\(z\\) direction.\r\n\r\nFig.11. structures\r\ncodes, (see ./examples/example6/example6.cpp)\r\n#include &quot;../../headers/structsystem.h&quot;using namespace std;struct Point&#123;    int id;    double x, y, z;&#125;;struct Element&#123;    int id;    int mat;    int typ;    int sec;    int p1, p2;&#125;;void importNodes(const string &amp;fname, vector&lt;Point&gt; &amp;v1)&#123;    ifstream fin;    fin.open(fname.c_str());    if (!fin.is_open())    &#123;        cerr &lt;&lt; fname &lt;&lt; &quot;: open file failed&quot; &lt;&lt; endl;        exit(-1);    &#125;    string line;    getline(fin, line);    char comma;    while (true)    &#123;        Point p;        fin &gt;&gt; p.id &gt;&gt; comma &gt;&gt; p.x &gt;&gt; comma &gt;&gt; p.y &gt;&gt; comma &gt;&gt; p.z;        if(!fin.good()) break;        v1.push_back(p);    &#125;    fin.close();&#125;void importElements(const string &amp;fname, vector&lt;Element&gt; &amp;v1)&#123;    ifstream fin;    fin.open(fname.c_str());    if (!fin.is_open())    &#123;        cerr &lt;&lt; fname &lt;&lt; &quot;: open file failed&quot; &lt;&lt; endl;        exit(-1);    &#125;    string line;    getline(fin, line);    char comma;    while (true)    &#123;        Element e;        fin &gt;&gt; e.id &gt;&gt; comma &gt;&gt; e.mat &gt;&gt; comma &gt;&gt; e.typ &gt;&gt; comma &gt;&gt; e.sec            &gt;&gt; comma &gt;&gt; e.p1 &gt;&gt; comma &gt;&gt; e.p2;        if(!fin.good()) break;        v1.push_back(e);    &#125;    fin.close();&#125;void saveExternalForce(const std::string &amp;path, Particle* p)&#123;    // create file    string fname = path + &quot;/particle_&quot; + to_string(p-&gt;id())+ &quot;.csv&quot;;    fstream fout;    fout.open(fname, ios::out | ios::app);    // write header    string header = &quot;PID, Fx, Fy, Fz, Mx, My, Mz&quot;;    fout &lt;&lt; header &lt;&lt; endl;    // write data    p-&gt;outputReactionForce(fout);    // close file    fout.close();&#125;int main()&#123;    // create system    StructSystem system = StructSystem(1);    system.setJobname(&quot;Star&quot;);    // solve parameters    double endTime = 100.0;    double zeta = 1;    double d = 6.0;    double rtime = 50.0;    // import structure parameters    string fnode = system.workdir() + &quot;/&quot; + &quot;nodes.csv&quot;;    vector&lt;Point&gt; points;    importNodes(fnode, points);    string felems = system.workdir() + &quot;/&quot; + &quot;elements.csv&quot;;    vector&lt;Element&gt; elements;    importElements(felems, elements);    // create particles    map&lt;int, Particle*&gt; particles;    for (int i = 0; i &lt; points.size(); i++)    &#123;        Particle* p = new Particle(points[i].id, points[i].x, points[i].y, points[i].z);        system.addParticle(p);        particles[points[i].id] = p;    &#125;    // create material    LinearElastic mat = LinearElastic(1);    mat.setE(1.0E6);    mat.setDensity(20);    // create section    CustomSectionParas paras = &#123;.A=0.1, .Sy=0, .Sz=0, .SHy=0, .SHz=0,                          .CGy=0, .CGz=0.0, .Iyy=0.01, .Izz=0.01, .Iyz=10&#125;;    CustomSection sect = CustomSection(1, paras);    // create elements    for (int i = 0; i &lt; elements.size(); i++)    &#123;        int id = elements[i].id;        int p1 = elements[i].p1;        int p2 = elements[i].p2;        Link3DLD* e = new Link3DLD(id, particles[p1], particles[p2],                           &amp;mat, &amp;sect);        system.addElement(e);    &#125;    // constraints    DOF v1 = &#123;.key=&#123;true, true, true, true, true, true&#125;,              .val=&#123;0, 0, 0, 0, 0, 0&#125;&#125;;    system.addConstraint(8, v1);    system.addConstraint(9, v1);    system.addConstraint(10, v1);    system.addConstraint(11, v1);    system.addConstraint(12, v1);    system.addConstraint(13, v1);    system.info();    string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/model&quot;;    system.saveModel(path);    StdArray6d d1 &#123;&#125;;    // setting parameters    double h = system.autoTimeStep();    system.setDampCoeff(zeta);    int nStep = ceil(endTime / h);    int interval = ceil(0.1 / h);    cout &lt;&lt; &quot;##### start calculating ######&quot; &lt;&lt; endl;    for (int i = 0; i &lt;= nStep; i++)    &#123;        d1[2] = -d * (double)i / nStep;        if (i == 0)        &#123;            system.setParticleDisplace(1, d1);            system.solve(h, zeta, true);            system.setInternalForce();        &#125;        else        &#123;            system.solve(h, zeta, false);            system.clearParticleForce();            system.setParticleDisplace(1, d1);            system.setInternalForce();        &#125;        // save results        if (i % interval == 0)        &#123;            string path = system.workdir() + &quot;/&quot; + system.jobname() + &quot;/&quot; +                          to_string(i * h);            system.saveParticleResult(path);            system.saveElementResult(path);            system.saveSupportReact(path);            saveExternalForce(path, particles[1]);            saveExternalForce(path, particles[2]);        &#125;    &#125;    cout &lt;&lt; &quot;##### finished ######&quot; &lt;&lt; endl;    system.releaseContainers();    return 0;&#125;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n​ Fig. 12 force-displace curve, (a) \\(F-U_z\\) at particle 1 (b) \\(F-U_x\\) at particle 2, (c) \\(F-U_z\\) at particle 2\r\nMore examples will be added in the near future, I believe you can get the basic concepts of openVFIFE.\r\nHope you can have a good experience in using openVFIFE.\r\nI will write a detailed documentation for users and developers once I graduate. And I am looking forward to your advices and suggestions.\r\nBest wishes!\r\n","categories":["openVFIFE"]}]